<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Solving Chess</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Solving Chess</h1>
<p class="date">2021-01-18T15:12:27-08:00</p>
</header>
<p>Chess has a <a href="https://en.wikipedia.org/wiki/Game_complexity#Complexities_of_some_well-known_games">game tree size</a> of about <span class="math inline">\(10^{123}\)</span>, so it will never be possible to solve chess by brute force. It might, however, be possible to solve chess practically by a combination of clever algorithms and formal analysis. Here are some ideas along those lines.</p>
<h2 id="preliminaries">Preliminaries</h2>
<p>Since the <a href="https://chess.stackexchange.com/questions/12470/if-there-was-perfect-play-from-both-sides-will-it-be-draw-or-win-for-one">consensus</a> seems to be that chess is a draw with perfect play, let’s assume that this is the case and think about how we might go about proving the game is a draw for black.</p>
<p>I use here the example of “depth-20-stockfish” as a deterministic, reasonably fast, often accurate assessment of a position. Of course, one could choose a different depth, or a different engine, such as the NNUE style engines that are in vogue these days (perhaps even an engine that has been fine tuned to make it easier to prove the specific guarantees we want to prove).</p>
<h2 id="weak-solution">Weak Solution</h2>
<p>One approach to solving a game is to provide a <a href="https://en.wikipedia.org/wiki/Solved_game">strong solution</a>, that is, an algorithm to give a perfect move from any legal position. There are on the order of <span class="math inline">\(10^{43}\)</span> chess positions according to the seminal <a href="https://vision.unipv.it/IA1/ProgrammingaComputerforPlayingChess.pdf">Shannon paper</a> on computer chess. Many of these positions, however, involve such weird configurations of pieces that you would never see them in a game of chess played even remotely rationally.</p>
<p>Here are three pictures of boards from games on <a href="https://lichess.org/">lichess</a>, and three pictures of boards generated by random moves. Can you tell which are which?</p>
<table>
<colgroup>
<col style="width: 32%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Board Pair 1: Which is the real game?</th>
<th>Board Pair 2 : Which is the real game?</th>
<th>Board Pair 3 : Which is the real game?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><img src="./img/board1.svg" alt="a" /></td>
<td><img src="./img/board2.svg" alt="a" /></td>
<td><img src="./img/randomboard3.svg" alt="a" /></td>
</tr>
<tr class="even">
<td><img src="./img/randomboard1.svg" alt="a" /></td>
<td><img src="./img/randomboard2.svg" alt="a" /></td>
<td><img src="./img/board3.svg" alt="a" /></td>
</tr>
</tbody>
</table>
<!-- <img src="/board1.svg" alt="A board" width="150">
<img src="../../static/randomboard1.svg" alt="A board" width="150">
<img src="../../static/randomboard2.svg" alt="A board" width="150">
<img src="../../static/board2.svg" alt="A board" width="150">
<img src="../../static/board3.svg" alt="A board" width="150">
<img src="../../static/randomboard3.svg" alt="A board" width="150"> -->
<p>This might be hard for a beginner, but if you’re an experienced player, you can probably spot the odd ones out pretty easily: Why would white develop their queen this way? Why are so many pieces hanging? This illustrates that an important tool in solving chess is identifying which positions are even possible to occur in a game of perfect chess.</p>
<p>All this makes it seem more prudent to offer a weak solution, which only gives answers for a subset of positions, enough to draw the game from the starting position.</p>
<p>How should we restrict the set of positions we consider? One way we could do this is to say something like “In any position, black can only choose from lines which have evaluation within 2 points of the best line, according to depth-20 stockfish evaluation”. This is (hopefully) permissive enough to not change black’s ability to draw, but restrictive enough to reduce the number of positions that we consider in the rest of our analysis. Note that it is possible to eliminate some positions by doing a retrograde analysis and checking if there is no sequence of moves to attain the position under black’s constraint.</p>
<h2 id="oracles-for-broad-classes-of-positions">Oracles for broad classes of positions</h2>
<p>In order to solve chess we will have to develop some computational notions of which positions are draws and which are losses. Chess engines do this, but the key difference here is that an engine can rely on heuristics that are sometimes inaccurate, while a program to formally solve chess will need to be much more precise about which positions it evaluates as wins, draws or losses, and which positions it cannot properly evaluate without more computational power than it has. Taking this into account, consider the problem of making an <em>incomplete chess oracle</em>: A program that takes a chess position and returns “Black wins or Draws” in some (but not necessarily all) positions where this is the case, and returns “Unknown” otherwise.</p>
<p>An endgame tablebase is an example of an incomplete chess oracle: It returns the result of endgames, and is agnostic about positions outside of its tablebase. Another example would be a chess engine which only returns an answer if it finds a forced mate or draw.</p>
<p>We can ask what the most effective incomplete chess oracle under constraints:</p>
<ul>
<li>The program must run in under 1 second on a laptop (or some formal model of a computing system with about this much power).</li>
<li>The program must minimize the number of <a href="#weak-solution">realistically reachable chess positions</a> for which it returns “Unknown”.</li>
</ul>
<p>Since this optimization question ranges over all algorithms, it is impossible to know exactly what the solution is. I would conjecture however, that the answer looks something like the following:</p>
<p><em>Run Stockfish on the position for 0.99 seconds, then return “Black Wins or Draws” if the score is at least -7.0 in Black’s favor. Build a list of positions for which this result is incorrect, and use the remaining time to check that the given position is not in that list before returning.</em></p>
<p>The correctness of this conjecture depends on whether the number of games that must be built into the program’s “exception table” can fit into the laptop’s memory. There are on the order of <span class="math inline">\(10^{43}\)</span> chess positions according to the seminal <a href="https://vision.unipv.it/IA1/ProgrammingaComputerforPlayingChess.pdf">Shannon paper</a> on computer chess. Some fraction of these will be unreachable under the constraints imposed in the previous section. Of those that remain, only a fraction will have evaluations this extreme in favor of black, and of these, many will have evaluations more extremely in favor of black, and will be very unlikely to be a win for white. As it is, the fraction of games with around a -7.0 evaluation will break heavily in favor of black, which we can estimate…</p>
<h3 id="estimating-accuracy-of-depth-20-stockfish">Estimating accuracy of depth 20 stockfish</h3>
<p>The fraction of positions for which depth-20-stockfish gives black a -7.0 score for Black but where white has a win is vanishingly small. However, we can still estimate it using a heuristic argument.</p>
<p>Consider chess positions in terms of two variables:</p>
<ul>
<li>Total material of both players, as a proxy for the stage of the game (78 possible values).</li>
<li>The depth-20 stockfish score discretized to the nearest 0.1, clipped to +-15.0.</li>
</ul>
<p>These variables divide all chess positions into one of ~24, 000 buckets. I can see the dynamics of a game with respect to these buckets by</p>
<ul>
<li>selecting random positions</li>
<li>If white is to move, choosing the next position by the depth-20-plus-<span class="math inline">\(k\)</span>-stockfish best line</li>
<li>If black is to move, choosing the next position by the depth-20-stockfish best line</li>
</ul>
<p>You can then compute the transition probability matrix between buckets, and create a Markov chain. This allows to estimate the fraction of positions with a -7.0 depth-20-stockfish score that result in a win for white (where black is depth-20-stockfish skill and white is depth-20-plus-<span class="math inline">\(k\)</span>-stockfish). We can then increase <span class="math inline">\(k\)</span> and see how this affects the win probability.</p>
<p>TODO code this</p>
<h2 id="finding-the-exception-table">Finding the exception table</h2>
<p>We have conjectured that the algorithm mentioned earlier provides an accurate oracle except for a large but manageable set of positions. How can we determine those positions?</p>
<p>We are looking for positions where depth 20 stockfish is different from depth 21 stockfish. Thus, we focus on the TODO</p>
<h2 id="using-the-oracle">Using the oracle</h2>
<p>TODO</p>
</body>
</html>
